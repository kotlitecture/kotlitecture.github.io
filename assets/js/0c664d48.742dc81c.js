"use strict";(self.webpackChunkkotli_docs=self.webpackChunkkotli_docs||[]).push([[1324],{6801:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>a,contentTitle:()=>o,default:()=>p,frontMatter:()=>s,metadata:()=>l,toc:()=>d});var n=i(4848),r=i(8453);const s={sidebar_position:4,title:"Template overview"},o=void 0,l={id:"engine/template_overview",title:"Template overview",description:"Each Kotli Template is a self-contained Kotlin artifact that encompasses all the necessary metadata for presentation and facilitates the multistep process of generating an output structure.",source:"@site/docs/engine/template_overview.md",sourceDirName:"engine",slug:"/engine/template_overview",permalink:"/engine/template_overview",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4,title:"Template overview"},sidebar:"tutorialSidebar",previous:{title:"Architecture",permalink:"/engine/architecture"}},a={},d=[{value:"Template",id:"template",level:2},{value:"Processor",id:"processor",level:2},{value:"1. Template Processor",id:"1-template-processor",level:3},{value:"2. Feature Provider",id:"2-feature-provider",level:3},{value:"3. Feature Processor",id:"3-feature-processor",level:3},{value:"4. File Rule",id:"4-file-rule",level:3},{value:"Examples",id:"examples",level:2}];function c(e){const t={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(t.p,{children:["Each ",(0,n.jsx)(t.strong,{children:"Kotli Template"})," is a self-contained Kotlin artifact that encompasses all the necessary metadata for presentation and facilitates the multistep process of generating an output structure."]}),"\n",(0,n.jsxs)(t.p,{children:["It comprises ",(0,n.jsx)(t.code,{children:"Template"})," and ",(0,n.jsx)(t.code,{children:"Processor"}),"."]}),"\n",(0,n.jsx)(t.mermaid,{value:"graph TD\n   P[Processor]\n   T[Template]\n   KT[Kotli Template]\n   \n   T --\x3e KT\n   P --\x3e KT"}),"\n",(0,n.jsx)(t.h2,{id:"template",children:"Template"}),"\n",(0,n.jsxs)(t.p,{children:['It serves as the initial blueprint for a project template structure without any limitations.\nThe structure can be written in any language, and technically, it doesn\'t even have to be a "project".\nThe crucial aspect is that this template is utilized by the ',(0,n.jsx)(t.code,{children:"Processor"})," to generate the resulting structure."]}),"\n",(0,n.jsx)(t.admonition,{type:"tip",children:(0,n.jsx)(t.p,{children:"It is recommended for this structure to be a functional example of a project, importable into an IDE as-is for testing and modification purposes."})}),"\n",(0,n.jsx)(t.h2,{id:"processor",children:"Processor"}),"\n",(0,n.jsx)(t.p,{children:"The initial blueprint template can include many dependencies and implement a ton of functionality, which usually is not needed by everyone."}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"Processor"})," serves two goals:"]}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsx)(t.li,{children:"Include only the required features into the output structure."}),"\n",(0,n.jsxs)(t.li,{children:["Provide any third-party solution that utilizes the artifact with all the required metadata describing the ",(0,n.jsx)(t.code,{children:"processor"}),"."]}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["Let's take a look at some existing ",(0,n.jsx)(t.code,{children:"processors"})," for a better understanding of the whole mechanics."]}),"\n",(0,n.jsxs)(t.p,{children:["Any external usage of the ",(0,n.jsx)(t.code,{children:"Kotli Template"})," occurs through its processor only."]}),"\n",(0,n.jsx)(t.mermaid,{value:'graph TD\n   class TemplateProcessor abstract\n   class FeatureProcessor abstract\n   class FeatureProvider abstract\n   Layer\n   TG["Template Generator"]\n   TS["TemplateContext"]\n   OS["Output Structure"]\n   subgraph TemplateProcessor\n       direction TB\n       FP1["Feature Provider 1"]\n       FPN["Feature Provider N"]\n       P1["Feature Processor 1"]\n       P2["Feature Processor 2"]\n       PN["Feature Processor N"]\n       R1["Rule 1"]\n       R2["Rule 2"]\n       R3["Rule 3"]\n       R4["Rule 4"]\n       R5["Rule 5"]\n       R6["Rule 6"]\n       RN["Rule N"]\n       FP1 --\x3e P1\n       FP1 --\x3e P2\n       FPN --\x3e PN\n       P1 --\x3e R1\n       P1 --\x3e R2\n       P2 --\x3e R3\n       P2 --\x3e R4\n       PN --\x3e R5\n       PN --\x3e R6\n       PN --\x3e RN\n       R1 --\x3e |apply|TS\n       R2 --\x3e |apply|TS\n       R3 --\x3e |apply|TS\n       R4 --\x3e |apply|TS\n       R5 --\x3e |apply|TS\n       R6 --\x3e |apply|TS\n       RN --\x3e |apply|TS\n   end\n\n    Layer --\x3e TemplateProcessor\n    TS --\x3e TG\n    TG --\x3e OS'}),"\n",(0,n.jsx)(t.h3,{id:"1-template-processor",children:"1. Template Processor"}),"\n",(0,n.jsxs)(t.p,{children:["A typical processor is an implementation of the ",(0,n.jsx)(t.code,{children:"BaseFeatureProcessor"})," class."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-kotlin",children:'class AndroidComposeTemplateProcessor : BaseTemplateProcessor() {\n\n    override fun getId(): String = "template-android-compose"\n    override fun getType(): LayerType = LayerTypes.Android\n    override fun getWebUrl(): String = "https://github.com/kotlitecture/template-android-compose"\n\n    override fun createProviders(): List<FeatureProvider> = listOf(\n        L10NProvider(),\n        NavigationProvider(),\n        SplashProvider(),\n        ThemeProvider(),\n        ...\n    }\n    \n    override fun prepare(state: TemplateState) {\n        state.onApplyRules(\n            "app/build.gradle",\n            ReplaceMarkedText(\n                text = "kotli.app",\n                marker = "{applicationId}",\n                replacer = state.layer.namespace,\n                singleLine = true\n            )\n        )\n        ...\n    }\n\n}\n'})}),"\n",(0,n.jsx)(t.p,{children:"Each implementation is responsible for overriding the given methods:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"getId()"})," - Defines the unique processor id. This id must be unique across all registered processors in the classpath."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"getType()"})," - Clarifies the type of the template and is used for a better understanding of its purpose."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"getWebUrl()"})," - Mostly an URL to the repository with the source codes of the template implementation. Although it's not required to link source codes, we prioritize open-source and its collaborative possibilities."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"createProviders()"})," - This is the main method. It registers all providers responsible for manipulating the blueprint template to form the required output architecture."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"prepare()"})," - Used to apply some ",(0,n.jsx)(t.code,{children:"rules"})," to the output structure before it is delegated to providers."]}),"\n"]}),"\n",(0,n.jsx)(t.h3,{id:"2-feature-provider",children:"2. Feature Provider"}),"\n",(0,n.jsx)(t.p,{children:"Feature providers are used to group different implementations of the same functionality by different vendors."}),"\n",(0,n.jsx)(t.p,{children:"Examples:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Your project requires the use of analytics events, and you want to log such events into one or multiple different services (Google Analytics, Amplitude, AppsFlyer)."}),"\n",(0,n.jsx)(t.li,{children:"Your project requires publication in different distribution channels (Maven, Google Artifact Registry, AWS CodeArtifact, etc.)."}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["In both scenarios, you can use either one or multiple services (",(0,n.jsx)(t.code,{children:"processors"}),"). Depending on the scenario, you will get all the required technical solutions to either log events into two systems using one common method or deploy artifacts into one or multiple systems using one generated pipeline."]}),"\n",(0,n.jsx)(t.admonition,{title:"\xa0",type:"tip",children:(0,n.jsx)(t.p,{children:"Feature Provider is responsible to group multiple similar services, present them to the user, and generate all required artifacts, making it possible to operate with the services as one."})}),"\n",(0,n.jsxs)(t.p,{children:["A typical feature provider is an implementation of the ",(0,n.jsx)(t.code,{children:"BaseFeatureProvider"})," class."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-kotlin",children:'class DistributionProvider : BaseFeatureProvider() {\n\n    override fun getId(): String = ID\n    override fun isMultiple(): Boolean = true\n    override fun getType(): FeatureType = FeatureTypes.DevOps\n\n    override fun createProcessors(): List<FeatureProcessor> = listOf(\n        FirebaseDistributionProcessor(),\n        GooglePlayDistributionProcessor()\n    )\n\n    companion object {\n        const val ID = "distribution"\n    }\n}\n'})}),"\n",(0,n.jsx)(t.p,{children:"Each implementation is responsible for overriding the given methods:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"getId"})," - Unique identifier of the provider. It must be unique only across other providers of the ",(0,n.jsx)(t.code,{children:"template processor"})," it is registered in."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"isMultiple"})," - Instructs the ",(0,n.jsx)(t.code,{children:"Template Processor"})," if it is possible to use several ",(0,n.jsx)(t.code,{children:"feature processors"})," in the output structure."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"getType"})," - Clarifies the type of the provider for a better understanding of its purpose."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"createProcessors"})," - Registers all ",(0,n.jsx)(t.code,{children:"feature processors"})," of the given provider."]}),"\n"]}),"\n",(0,n.jsx)(t.h3,{id:"3-feature-processor",children:"3. Feature Processor"}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"Feature Processor"})," is responsible for the inclusion or exclusion of the feature it implements in the generated template.\nA ",(0,n.jsx)(t.code,{children:"feature"})," is any atomic integration, technical solution, or business flow that can be added to a layer during its configuration in ",(0,n.jsx)(t.code,{children:"Kotli"}),".\nEach feature should be self-descriptive, allowing it to be presented to the user with an ",(0,n.jsx)(t.code,{children:"icon"}),", ",(0,n.jsx)(t.code,{children:"title"}),", ",(0,n.jsx)(t.code,{children:"description"}),", ",(0,n.jsx)(t.code,{children:"links"}),", and any ",(0,n.jsx)(t.code,{children:"other metadata"})," required to understand its value and purpose.\nThe primary advantage of a feature is to provide a ready-to-use solution with minimal configuration required (zero configuration is the goal)."]}),"\n",(0,n.jsxs)(t.p,{children:["A typical feature processor is an implementation of the ",(0,n.jsx)(t.code,{children:"BaseFeatureProcessor"})," class."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-kotlin",children:'class FirebaseDistributionProcessor : BaseFeatureProcessor() {\n\n    override fun getId(): String = ID\n    override fun getWebUrl(state: TemplateState): String = "https://firebase.google.com/docs/app-distribution"\n    override fun getIntegrationUrl(state: TemplateState): String = "https://firebase.google.com/docs/app-distribution/android/distribute-gradle"\n\n    override fun dependencies(): List<Class<out FeatureProcessor>> = listOf(\n        GoogleServicesProcessor::class.java,\n        FirebaseProcessor::class.java\n    )\n\n    override fun doApply(state: TemplateState) {\n        state.onApplyRules("app/build.gradle",\n            CleanupMarkedLine("{firebase-distribution}"),\n            CleanupMarkedBlock("{firebase-distribution-debug}"),\n            CleanupMarkedBlock("{firebase-distribution-staging}")\n        )\n        ...\n    }\n\n    override fun doRemove(state: TemplateState) {\n        state.onApplyRules("app/build.gradle",\n            RemoveMarkedLine("{firebase-distribution}"),\n            RemoveMarkedBlock("{firebase-distribution-debug}"),\n            RemoveMarkedBlock("{firebase-distribution-staging}")\n        )\n        ...\n    }\n\n    companion object {\n        const val ID = "firebase-distribution"\n    }\n\n}\n'})}),"\n",(0,n.jsx)(t.p,{children:"Each implementation is responsible for overriding the given methods:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"getId"})," - Unique identifier of the processor. It must be unique only across other processors of the ",(0,n.jsx)(t.code,{children:"template processor"})," it is used in."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"getWebUrl"})," - Any official URL of the underlying functionality for a better understanding of its purpose by the user."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"getIntegrationUrl"})," - Any public URL of the integration guide for this feature. This guide is not required when the feature is included. Instead, it is just a knowledge base of the sources used to integrate the feature."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"dependencies"})," - If the feature has any dependencies on other features, the processor will apply them first to the prepared structure. The dependencies must also be registered in the ",(0,n.jsx)(t.code,{children:"template processor"})," through ",(0,n.jsx)(t.code,{children:"feature providers"}),"."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"doApply"})," - When the feature is selected by the user, this method is used to apply some ",(0,n.jsx)(t.code,{children:"rules"})," to the files affected by the feature in the blueprint template. It is not required that such files exist in the original template."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"doRemove"})," - When the feature is not selected by the user, this method will be called to ",(0,n.jsx)(t.code,{children:"cleanup"})," the template from any changes specific to the feature only."]}),"\n"]}),"\n",(0,n.jsx)(t.h3,{id:"4-file-rule",children:"4. File Rule"}),"\n",(0,n.jsx)(t.p,{children:"Any rule to be applied to a file from the blueprint template during the generation of the output structure."}),"\n",(0,n.jsx)(t.admonition,{title:"\xa0",type:"info",children:(0,n.jsx)(t.p,{children:"It is not required that file exists in the original template."})}),"\n",(0,n.jsxs)(t.p,{children:["A typical rule is an implementation of the ",(0,n.jsx)(t.code,{children:"FileRule"})," class."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-kotlin",children:"class CleanupMarkedLine(\n    private val marker: String,\n    private val singleLine: Boolean = false\n) : FileRule() {\n\n    override fun doApply(file: TemplateFile) {\n        val lines = file.lines\n        lines.forEachIndexed { index, line ->\n            if (isMarked(file, line, marker)) {\n                lines[index] = cleanup(file, line)\n                if (singleLine) return\n            }\n        }\n    }\n\n}\n"})}),"\n",(0,n.jsxs)(t.p,{children:["Each ",(0,n.jsx)(t.code,{children:"file rule"})," requires implementing only one method, ",(0,n.jsx)(t.code,{children:"doApply"}),". This method is called during the final stage of the generation phase."]}),"\n",(0,n.jsx)(t.admonition,{type:"tip",children:(0,n.jsx)(t.p,{children:"FileRule is not bound to a file it modifies."})}),"\n",(0,n.jsx)(t.admonition,{type:"info",children:(0,n.jsx)(t.p,{children:"It is possible to implement any rule with any underlying template engine to process the input file."})}),"\n",(0,n.jsx)(t.admonition,{type:"warning",children:(0,n.jsx)(t.p,{children:"The engine allows applying different rules to the same file. In such cases, each subsequent rule will operate with the modified version of the file."})}),"\n",(0,n.jsx)(t.h2,{id:"examples",children:"Examples"}),"\n",(0,n.jsx)(t.p,{children:"Before delving deep into the details, it is recommended to check how existing templates look. Here are some examples:"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:["Android Compose Application - ",(0,n.jsx)(t.a,{href:"https://github.com/kotlitecture/template-android-compose",children:"https://github.com/kotlitecture/template-android-compose"})]}),"\n",(0,n.jsxs)(t.li,{children:["Spring Boot Application - ",(0,n.jsx)(t.a,{href:"https://github.com/kotlitecture/template-backend-spring-boot",children:"https://github.com/kotlitecture/template-backend-spring-boot"})]}),"\n"]})]})}function p(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}}}]);